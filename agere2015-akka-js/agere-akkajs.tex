% !TEX encoding = UTF-8
% !TEX program = pdflatex

% This is "sig-alternate.tex" V2.0 May 2012
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.5 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.5) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

\documentclass{sig-alternate}
\usepackage[utf8]{inputenc}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{AGERE!}{'15 Pittsburgh, Pennsylvania, USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Towards a portable actor runtime environment}

%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{3} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Gianluca Stivan\\
       \affaddr{UniCredit R\&D}\\
       \affaddr{Italy}\\
       \email{Gianluca.Stivan@stud-inf.unibz.it}
% 2nd. author
\alignauthor
Andrea Peruffo\\
       \affaddr{UniCredit R\&D}\\
       \affaddr{Italy}\\
       \email{Andrea.Peruffo@unicredit.eu}
% 3rd. author
\alignauthor Philipp Haller\\
       \affaddr{KTH Royal Institute of Technology}\\
       \affaddr{Sweden}\\
       \email{phaller@kth.se}
\and  % use '\and' if you need 'another row' of author names
% 4th. author
% \alignauthor Lawrence P. Leipuner\\
%        \affaddr{Brookhaven Laboratories}\\
%        \affaddr{Brookhaven National Lab}\\
%        \affaddr{P.O. Box 5000}\\
%        \email{lleipuner@researchlabs.org}
}

\maketitle
\begin{abstract}
Multiple mature implementations of the actor model of concurrency exist. Besides several implementations for Java virtual machines, there are implementations, for example, written in SmallTalk or in C++, targeting native platforms. Recently, runtime environments for platforms such as GPUs have appeared.

However, so far, no full-featured actor runtime environment has allowed actor programs to run, unchanged, on both Java and JavaScript virtual machines. This paper describes our ongoing effort in providing a portable implementation of the widely-used Akka actor runtime.
\end{abstract}

% A category with the (minimum) three required fields
% \category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
% \category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

% \terms{Theory}

\keywords{Actors, Portability, Java, JavaScript}

\section{Introduction}

In recent times, there has been a significant pique of interest regarding JavaScript. The language, originally developed by Brendan Eich, while working at Netscape, and once confined to browsers, is now being used to power a wide variety of projects, ranging from server side applications \cite{web:nodejs} to hardware \cite{web:tessel} to robots \cite{web:johnnyfive}.


With the rise of this programming language, a need has emerged for a pattern which can easily manage concurrent and distributed scenarios. Current approaches in the JavaScript world include the usage of callbacks and promises: the former of which has the unfortunate side-effect of forcing inversion of control, while the latter has no built-in solution for distributed computing.


In 1973, a joint effort between Carl Hewitt, Peter Bishop and 
Richard Steiger resulted in the Actor Model. Presented in a paper  published in 1973, this revolutionary architecture was, according to its creators, inspired by physics and programming languages such as Simula and LISP. The philosophy at the foundation of this model is that everything is an actor, where an actor is an entity which does exactly three things:
\begin{itemize}
\item[-] send messages to other actors 
\item[-] create a finite number of actors 
\item[-] react with a defined behaviour to the next incoming message 
\end{itemize}
Every actor is identified by an \textit{address}, which uniquely identifies it in the domain. The address is particularly interesting because it introduces the notion of \textit{location transparency}, meaning that the physical location of an actor is unnecessary, as long as an address pointing to it is correct, because the framework mechanism will ensure delivery.

Porting Akka to the JavaScript runtime presents numerous advantages. For starter, it brings an arguably very good model, which handles concurrency and fault handling admirably, to a runtime which lacks good support for both. Moreover, it promotes state isolation, which makes reasoning about the application easier for programmers. Finally the message passing abstraction fits incredibly well to all kind of I/O operations that JavaScript provides. WebSockets, WebWorkers, AJAX and DOM Events are all asynchronous and event-based, making a wrapper that forwards events as messages to actors both convenient and simple to use at the same time.


The paper proceeds as follows. We first give a brief overview of Akka and its API. We then discuss at length the major problems encountered during the development of Akka.js which include the heavy reliance on JVM constructs (data structures, patterns and libraries), usage of reflection and blocking APIs and finally serialization. We also detail the solutions adopted to circumvent the issues presented. 

An overview of the source code organization is presented and, finally, some extensions to Scala.js, the Scala to JavaScript compiler, are introduced which were developed to ensure cross-compatibility between Akka.JVM and Akka.js.

\subsection{Previous and related work}

Scala-js-actors, as previously mentioned, is a project that was developed as a semester project by
EPFL PhD student SÃ©bastien Doeraene in fall 2013.\\
Doeraene is the creator of Scala-js, a Scala to JS compiler, and scala-js-actors was designed as a
way to prove Scala-js' real world capabilities.\\
The code contains a small subset of the entire Akka.JVM codebase, but is already able to provide 
support for actors, supervision and fault-tolerancy.
Scala-js-actors was further extended to provide interoperability with an Akka backend through
WebSockets and multicore capabilities using WebWorkers.
While an amazing piece of engineering, the limits of scala-js-actors are:
\begin{itemize}
\item[-] no relationship with the original Akka codebase
\item[-] no testing suite
\item[-] different semantics from Akka.JVM remote, the Akka module for communicating with remote nodes
\end{itemize}
To elaborate a bit further, the first two points where due to the fact that scala-js-actors was a research
project, a proof of concept of the maturity of Scala.js, hence it was not designed with a long-term strategy
in mind.
The third point is more vital. Akka.JVM remote is the component that allows different JVMs to seamlessly
communicate between them using the same abstraction that one would use for local actors. It's the ultimate
implementation of the location transparency concept of the actor model.
Whereas in Akka.JVM the programmer needs only to configure the cluster and there is no perceivable difference between 
remote and local actors (please note that Scala, as Erlang, uses the \emph{a ! msg} notation to denote a message \emph{msg}
being sent to an actor \emph{a}):

\section{Akka's API}


Akka.js is the core project of this thesis and builds on \textit{scala-js-actor}, a previous PhD 
semester project developed at Ãcole polytechnique fÃ©dÃ©rale de Lausanne by SÃ©bastien Doeraene. 
The original codebase has been pretty much rewritten from scratch to more closely mimic the 
Akka.JVM code, but Doeraene's work has served as a great source of inspiration for this thesis.
What Akka.js really is, is a partial port of the Akka ecosystem to Scala.js, which allows 
Akka programs to run directly everywhere JavaScript is available. It achieves this by 
replacing all the Java Virtual Machines dependencies with their JavaScript counterparts 
while keeping the semantics of the library unchanged.
\\\\


The project also provided some interesting challenges, some of which are mentioned below.
The biggest problem that arose was the heavy dependency on JVM code that Akka.JVM has. JVM code is intertwined with code that
can be shared with Akka.JS and there is no easy way to remove it. Examples of such dependency are threads, JVM data structures
and JS semantics differing from the JVM.
The problem was solved in two ways. First, code was divided in two directories, one with JavaScript specific code, another with
code that is shared with Akka.JVM. Second, the JavaScript specific code was rewritten from scratch to allow Akka to run in JavaScript 
runtimes with the same semantics as in the Java Virtual Machine.
\\
A further problem which was encountered during the development of Akka.js was due to the reflection usage on the JVM. Reflection is
a feature of the Java SDK which allows a programmer to inspect an object at runtime and interact with it in ways that would not 
normally be possible. Unfortunately, support for such features is non-existent in the JavaScript runtime, so it was necessary to
develop a custom solution. A subset of the \emph{java.lang.reflect} APIs was developed, which is semantically identical to the JVM
counterparts. A proposal has also been submitted to the Scala.js core team, to allow for a tighter integration with the compiler. 
If the proposal is accepted, this will result in a superior kind of integration and it will be possible to definitely eliminate the
last hacky bits in the code.
\\
Finally, the usage of JVM's blocking APIs in the test code has proven to be quite the source of difficulties. Given its single threaded
nature it is not normally possible to block in a JavaScript runtime, effectively rendering the available Akka test code unusable.
The limitation was circumvented by writing a custom event loop dispatcher that allows for blocking operations. Normally this would result
in a deadlock, but given the asynchronous nature of Akka, the only blocking code is the test itself, so it ends up working just fine.


\section{Portable runtime environment}

\subsection{JavaScript's execution model}

\subsection{Akka.js}

\subsection{Source code organization}

\section{Extensions to Scala.js}

\section{Conclusion and future work}

A project was presented, which focuses on cross-compiling Akka to JavaScript, effectively enabling Akka programs to run in different 
JavaScript runtimes (browsers, Node.js and Phantom.JS to name a few).
Akka.js leverages the ubiquity of JavaScript and empowers a whole new set of complex abstractions to be easily managed from one
unique interface, thanks to the elegance of the Actor Model. Different use cases where presented which explain how the project
has practical use cases and can already be used to solve real world problems.
Moreover, as the Akka project is evolving and turning from a simple implementation of the Actor Model, to a complex platform
which can support different kind of reactive applications, the potential for the evolution of Akka.js is enourmous.
There are many modules which still compose Akka.JVM and it would be interesting to explore the possibilities that some of them
enable. For instance:
\begin{itemize}
\item[-] Akka Cluster provides a fault-tolerant decentralized peer-to-peer based cluster membership service with no single point of failure or single point of bottleneck.
\item[-] Akka Streams is an implementation of Reactive Streams, which is a standard for asynchronous stream processing with non-blocking backpressure (meaning that data 
are pulled, instead of pushed, to allow for flow control)
\item[-] Akka Typed is an extension providing statically typed actors
\end{itemize}
In conclusion, Akka is a mature project with strong potential and Akka.js is a first step to harnessing this capability to 
improve the way software is written for the web.

%\end{document}  % This is where a 'short' article might terminate

%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}
This section is optional; it is a location for you
to acknowledge grants, funding, editing assistance and
what have you.

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{sigproc}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%

% That's all folks!
\end{document}
